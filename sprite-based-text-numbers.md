# Chunky Pixel Fonts (Late‑70s Programming Style)

This document defines **fonts as sprite data**, not typography. The goal is **visible blocks, fixed grids, and deliberate crudeness**, inspired by late‑1970s arcade and home console graphics (Atari 2600 era and earlier).

This is **not** about font rendering systems, vector paths, kerning, or typographic aesthetics.

It is about:

* Turning grid cells on/off
* Shipping PNG sprites
* Composing numbers and letters manually in‑game

---

## 1. What “Font” Means Here

A *font* is:

* A **collection of small bitmap sprites**
* Each glyph drawn on a **fixed pixel grid**
* No curves, no smoothing, no scaling

Each character is effectively a **tiny programmatic pattern**.

Think:

```
FOR y = 0 TO 7
  FOR x = 0 TO 7
    IF cell[x,y] == ON THEN draw pixel
```

That mindset is correct.

---

## 2. Design Constraints (Intentional Limits)

These limits are **features**, not restrictions.

* **Fixed grid size per glyph** (examples: 5×7, 8×8, 8×10)
* **Monospaced only** (every glyph same width)
* **Very small palette** (2–4 colors max)
* **Hard pixel edges** (no anti‑aliasing)
* **Integer scaling only** (1×, 2×, 3× — never fractional)

If it feels slightly uncomfortable or crude, you are doing it right.

---

## 3. Recommended Grid Sizes

### Ultra‑primitive (very early feel)

* **5×7** or **6×7**
* Barely legible
* Feels like firmware output or ROM diagnostics

### Classic chunky (recommended)

* **8×8**
* Enough structure to feel intentional
* Strong Atari / early arcade vibe

### Slightly more expressive

* **8×10** or **8×12**
* Better for titles
* Still visibly block‑based

Pick **one grid** and never break it.

---

## 4. Glyph Construction Rules

Each glyph:

* Occupies its full grid (even if mostly empty)
* Aligns to the same baseline
* Uses **solid rectangles only**

Avoid:

* Diagonals that try to look smooth
* Decorative holes or flourishes
* Any illusion of curves

Blocky > clever.

---

## 5. Numbers (Score, Counters, Goals)

Numbers should:

* Be **the most legible glyphs**
* Share identical width
* Avoid interior decoration (no scanlines, no shading)

Typical approach:

* One PNG per digit (`digit_0.png` … `digit_9.png`)
* Each digit exactly the same pixel size
* Composed side‑by‑side at runtime

No font engine. No text APIs.

---

## 6. Letters (Optional, Not Always Needed)

Early games often:

* Used **numbers only** for gameplay
* Used **bitmap title screens** for text

If letters are needed:

* Uppercase only (A–Z)
* No lowercase
* Same grid as numbers

Lowercase introduces unnecessary complexity and modernity.

---

## 7. Title Screens

Two historically accurate approaches:

### A. Single Bitmap Title

* Entire title drawn as one image
* No reusable glyphs
* Most authentic

### B. Large Letter Sprites

* Same system as numbers
* Bigger grid (e.g. 16×16 per letter)
* More flexible, more work

Late‑70s feel favors **A**.

---

## 8. Color Palette

Keep it primitive:

Examples:

* Black / Yellow
* Black / Green
* Black / Red
* Black / White

Avoid gradients, shadows, or outlines.

Flat color + empty space is correct.

---

## 9. File Organization

Recommended structure:

```
Assets/
  Fonts/
    Digits_8x8/
      digit_0.png
      digit_1.png
      ...
    Letters_8x8/
      A.png
      B.png
      ...
```

SpriteKit will pack these into an atlas.

---

## 10. Rendering Rules (Non‑Negotiable)

In SpriteKit:

* Disable texture filtering
* Never scale sprites by non‑integers
* Align sprites to pixel boundaries

If pixels blur, something is wrong.

---

## 11. Success Criteria

You are doing this correctly if:

* You can count individual squares with your eye
* The text feels almost *too simple*
* It looks like it could be generated by early hardware

If it starts to feel like design, you have gone too far.

---

## 12. Guiding Principle

> These are not fonts.
> They are **data tables of illuminated squares**.

That framing will keep every decision aligned with your goal.
